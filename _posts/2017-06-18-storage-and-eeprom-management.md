---
ID: 419
post_title: Storage and EEPROM management
author: impeccableaslan
post_date: 2017-06-18 16:17:02
post_excerpt: ""
layout: post
permalink: >
  http://rcnode.com/index.php/2017/06/18/storage-and-eeprom-management/
published: true
---
[et_pb_section fb_built="1" admin_label="section" _builder_version="3.0.47"][et_pb_row admin_label="row" _builder_version="3.0.47" background_size="initial" background_position="top_left" background_repeat="repeat"][et_pb_column type="4_4" _builder_version="3.0.47" parallax="off" parallax_method="on"][et_pb_text admin_label="Text" _builder_version="3.0.47" background_size="initial" background_position="top_left" background_repeat="repeat"]
					
				[/et_pb_text][et_pb_text _builder_version="3.0.51"]<p>The boards Ardupilot supports have persistent storage. This storage is used to save user parameters, rally points, waypoints, terrain data and other useful things. Access to this storage is provided through four mechanisms:</p>
<p>&nbsp;-The StorageManager library to give a higher level abstraction layer on <g class="gr_ gr_62 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="62" data-gr-id="62">hal</g>.storage</p>
<p><span>-</span><span>the <g class="gr_ gr_76 gr-alert gr_gramm gr_inline_cards gr_run_anim Style replaceWithoutSep" id="76" data-gr-id="76">AP_HAL::Storage</g> object, accessed as <g class="gr_ gr_63 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="63" data-gr-id="63">hal</g>.storage</span></p>
<p>-<g class="gr_ gr_64 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="64" data-gr-id="64">Posix</g> IO functions to traditional filesystems (for example VFAT on a microSD card), on supported boards</p>
<p>-DataFlash for storing to an on-board logging area</p>
<p>&nbsp;</p>
<p>Posix: The Portable Operating System Interface is initially a standard specified by the IEEE Computer <g class="gr_ gr_56 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="56" data-gr-id="56">society</g> to maintain compatibility between operating systems. <g class="gr_ gr_57 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="57" data-gr-id="57">Posix</g> IO (Input, output) is the standard way for Linux to transfer data, hence to traditional filesystems</p>
<p><g class="gr_ gr_60 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="60" data-gr-id="60">Dataflash</g>: This is a serial interface with <g class="gr_ gr_61 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="61" data-gr-id="61"><g class="gr_ gr_74 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar only-ins doubleReplace replaceWithoutSep" id="74" data-gr-id="74">low-pin</g> count</g> for flash memory. Flash memory is an electronic computer storage that can be electrically erased and reprogrammed. It is non-volatile, that is its stored information can be retrieved even after having been power cycled (Turning it on and off)</p>
<p>&nbsp;Other such libraries or functions requiring persistent storage access it through these mechanisms. For example, the library AP_Param library (of which is in charge of user settable parameters) is based on StorageManager, of which is built on <g class="gr_ gr_72 gr-alert gr_gramm gr_inline_cards gr_run_anim Style replaceWithoutSep" id="72" data-gr-id="72">AP_HAL::Storage.</g></p>
<p>&nbsp;EEPROM:&nbsp; Electrically erasable programmable read-only memory. A read-only memory whose contents can be erased and reprogrammed using a pulsed voltage. A pulsed voltage occurs when rectification <g class="gr_ gr_66 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="66" data-gr-id="66">occur</g> and rectification is the conversion of alternating current to direct current through a rectifier.</p>
<p>FRAM: Ferroelectric RAM is a random access memory. It is non-volatile. A random-access memory device allows data items to be read or written in almost the same amount of time regardless of the physical location of data inside the memory</p>
<h1></h1>
<h1>The <g class="gr_ gr_58 gr-alert gr_gramm gr_inline_cards gr_run_anim Style replaceWithoutSep" id="58" data-gr-id="58">AP_HAL::Storage</g> library:</h1>
<p>The minimum storage size available through this interface on boards supported by Ardupilot is 4096 bytes. There are boards that provide more space, such as the PX4v1 of which has 8k of EEPROM.</p>
<p>The API for <g class="gr_ gr_52 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="52" data-gr-id="52">hal</g>.storage is as follows:</p>
<p>-init() to initiate the storage subsystem</p>
<p>-read_block() to read block of bytes</p>
<p>-write_block() to write block of bytes&nbsp;</p>
<p>With this simple API, developers will be better off to use the StorageManager API instead of <g class="gr_ gr_54 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="54" data-gr-id="54">hal</g>.storage. You should only use <g class="gr_ gr_55 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="55" data-gr-id="55">hal</g>.storage when installing a new board or during debugging.</p>
<p>The storage size available is set within AP_HAL/AP_HAL_Boards.h in "HAL_STORAGE_SIZE". Meaning this does not support dynamically changing the size of storage available within the interface. For dynamically sized storage, <g class="gr_ gr_53 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="53" data-gr-id="53">Posix</g> IO has to be used.</p>
<h1></h1>
<h1>The StorageManager library</h1>
<p>For the actual use of available storage, StorageManager is here to serve that purpose. This provides an API that sorts the storage into blocks of data with an assigned purpose:</p>
<p>-Fence points</p>
<p>-Parameters</p>
<p>-Waypoints</p>
<p>-Rally points</p>
<p></p>
<p>Non-contiguous: Contiguous means immediately adjacent. For example, contiguous sectors on a disk are sectors that come one after the other. Frequently, a file stored on disk can become fragmented, which means that it is stored on non-contiguous sectors.</p>
<p>Go and have a read of libraries/StorageManager/StorageManager.cpp. In particular look at the tables at the top. Notice how multiple areas of each type are defined for systems with <g class="gr_ gr_241 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="241" data-gr-id="241">have</g> larger amounts of storage. This ability to combine multiple non-contiguous areas of storage into a single logical storage area was the main motivation for adding StorageManager. It allowed us to grow from using 4k of storage on all boards to using the full storage available on each board without asking users to reload all their parameters or reload their waypoints.</p>
<p>The theme of avoiding having users to reconfigure their autopilot boards is a reoccurring one in Ardupilot. It is convenient for the user to be able to update to the latest firmware and still retains their previous settings.</p>
<p>This StorageManager API provides functions for reading and writing variables like integers as well. This API is used in libraries such as AP_Mission to save and restore waypoints.</p>
<p>Offsets: Offsets are an integer indicating the distance between the beginning of the object to a given point. These are mostly used in the context of arrays.</p>
<p>This is a stress test for the StorageManager: libraries/StorageManager/examples/StorageTest.cpp. It is also a test for the AP_HAL:: Storage object. It <g class="gr_ gr_247 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="247" data-gr-id="247">do</g> this by having random inputs and outputs of different offsets (So from a given range) of random lengths. This would result in values chosen by the random IO of which crosses the boundaries set by the array or the hardware (The hardware can only allocate so <g class="gr_ gr_248 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="248" data-gr-id="248">much</g> digits for a number). This value would be fragmented into pieces within FRAM or EEPROM storage if these are used. This test is made to stress test the StorageManager API but is also very useful should the Ardupilot be ported to a new board as it can stress the EEPROM as well to get its specifications.</p>
<p>&nbsp;Go and try StorageTest on your board, but be warned that it is a destructive test. It won&rsquo;t destroy your board, but it will wipe all your parameters and waypoints. So backup <g class="gr_ gr_244 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling" id="244" data-gr-id="244">your</g> configuration if you are testing on the board in your <g class="gr_ gr_243 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling multiReplace" id="243" data-gr-id="243">favourite</g> aircraft. As an exercise, add some profiling to StorageTest so it prints the total IO rate in <g class="gr_ gr_239 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="239" data-gr-id="239">kbytes</g>/sec along with the IO rate for reads and writes. Do you notice something about the difference between the read and write rates? Do you notice anything about the speed of writing values which are already set at that address in storage? See if you can find the code in StorageManager that explains your observations. Then submit a patch adding the profiling output to the ArduPilot <g class="gr_ gr_240 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="240" data-gr-id="240">github</g>.</p>
<p>Go and search through the ArduPilot libraries to fine all the places that use the StorageManager. What you are looking for is StorageAccess handles, like this:</p>
<p>StorageAccess AP_Param::_storage(StorageManager::StorageParam);</p>
<p>that declares a variable called AP_Param::_storage which provides access to the StorageParam area of the storage on this board.</p>
<h1></h1>
<h1>The DataFlash library</h1>
<p>A type of storage that Ardupilots needs is for <g class="gr_ gr_349 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling" id="349" data-gr-id="349">on-board</g> logs. The DataFlash library does just that. It was initially a hardware device, driver, and library which is converted <g class="gr_ gr_350 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling" id="350" data-gr-id="350">overtime</g> into a general logging system. This poses as a negative impact on the structure of the library.</p>
<p>Nowadays, the DataFlash API is designed around a logging infrastructure model. This allows the user to define data structures to log individual messages such as "GPS" message to log data from GPS sensors. Individual log messages where the individual means "something", so the term would refer to creating log messages for <g class="gr_ gr_369 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling multiReplace" id="369" data-gr-id="369">self defined</g> objects. DataFlash can handle logging data to persistent storage in an efficient way and provides APIs for other libraries so that the other libraries can get their data back should the user want to download their log files after the flight has ended.</p>
<p>Ground station: It is essentially the station that controls the UAV, so the radio controller/ the flyer</p>
<p>If you have seen the &lsquo;*.bin&rsquo; files that ArduPilot uses these days when you download a log then you have seen the format that ArduPilot uses to store log messages. It is &ldquo;<g class="gr_ gr_367 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling multiReplace" id="367" data-gr-id="367">self describing</g>&rdquo;, meaning that the ground station can work out the format of the messages in the log file without having to have some common scheme. At the front of each log file is a set of FMT messages which have a <g class="gr_ gr_370 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling multiReplace" id="370" data-gr-id="370">well known</g> format and which describe the format of the messages that follow.&nbsp;</p>
<p>As those files are <g class="gr_ gr_358 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling multiReplace" id="358" data-gr-id="358">self describing</g>, thus the radio controller should be able to work out the format of the files regardless of whether it contains common schemes (Distinctive features of language/format) or not. The end of each log file <g class="gr_ gr_360 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="360" data-gr-id="360">are</g> FMT messages (A part of the Go language which has unique features) of which describes the format of messages that follow.</p>
<p>Go and have a look at libraries/DataFlash/examples/DataFlash_test/DataFlash_test.cpp. You&rsquo;ll see a little table at the top that defines the log messages we will be writing, in this <g class="gr_ gr_352 gr-alert gr_gramm gr_inline_cards gr_run_anim Punctuation only-ins replaceWithoutSep" id="352" data-gr-id="352">case</g> a &lsquo;TEST&rsquo; message which contains 4 unsigned <g class="gr_ gr_354 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling multiReplace" id="354" data-gr-id="354">16 bit</g> integers and two signed <g class="gr_ gr_355 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling multiReplace" id="355" data-gr-id="355">32 bit</g> integers (that is what &ldquo;HHHHii&rdquo; means). It also gives names for those 6 variables (cunningly <g class="gr_ gr_356 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling multiReplace" id="356" data-gr-id="356">labelled</g> V1 to V4 and L1 and L2).</p>
<p>Within the loop function, there lies a strange call like:</p>
<p>DataFlash.get_log_boundaries(log_num, start, end);</p>
<p>This is the format for a public API of which hides how DataFlash library stores log files. On systems using <g class="gr_ gr_347 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="347" data-gr-id="347">Posix</g> IO (Pixhawk, Linux, etc) log files are stored in a "LOGS" directory in the MICROSD card. The user can copy log files <g class="gr_ gr_336 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="336" data-gr-id="336">on</g> the card by pulling the MICROSD card and plugging it into their computer.</p>
<p>On boards similar to APM2, they contain 4 megabytes of storage on a DataFlash chip of which is accessed through <g class="gr_ gr_376 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="376" data-gr-id="376">a SPI</g> interface. This interface uses the concept of a "Page", each page can hold up to 512 bytes of data and after each page has been filled with 512 bytes of data, you will need to tell the chip to copy that page to a persistent storage while the chip continues to fill the next page. Therefore with this concept of "Page", random IO is not good for this chip -&nbsp; this chip is designed to be used by code that writes continuously, just like the process of logging. 4 megabytes of storage isn't ideal for logging however so we need to handle wrapping when it fills up as well.</p>
<p>All of this is hidden behind the API mentioned at the start. The API presents a "log number", sort of like an identification built from a bunch of bytes written during the flying of the Ardupilot. APM1 and APM2 use marker bytes at the beginning of each page to say which "Log number" is being written. Should the user ask to retrieve their logs, the "Log number" will correspond to the "Log number" that are downloaded.</p>
<h1></h1>
<h1><g class="gr_ gr_426 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="426" data-gr-id="426">Posix</g> IO</h1>
<p>There are boards that Ardupilot support of which are based on operating systems that have a Posix-like API. An instance of this is Linux ports of which have <g class="gr_ gr_483 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="483" data-gr-id="483">Posix</g> subsystems. We can avail ourselves of this as long as we don&rsquo;t use it for anything that has to function on all boards.</p>
<p>An example of the use of this is the AP_Terrain library of which holds terrain data. Terrain data is far too large for EEPROM and as it is random access, it is not suitable for DataFlash. As it is not essential for the basic operating of the drone, it can be implemented using <g class="gr_ gr_478 gr-alert gr_spell gr_inline_cards gr_run_anim ContextualSpelling ins-del multiReplace" id="478" data-gr-id="478">Posix</g> IO.</p>
<p>Marco: Marco is a rule or pattern that specifies how a certain input sequence (often a sequence of characters) should be mapped to a replacement output sequence&nbsp;</p>
<p>The way <g class="gr_ gr_484 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="484" data-gr-id="484">Posix</g> IO is used is by first checking if the board has <g class="gr_ gr_485 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="485" data-gr-id="485">Posix</g> IO support. On Ardupilot this is done by checking the <g class="gr_ gr_486 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="486" data-gr-id="486">marco</g>: HAVE_OS_POSIX_IO from AP_HAL_Boards.h. To know where to store the acquired data, add a data specific <g class="gr_ gr_487 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="487" data-gr-id="487">marco</g> in AP_HAL_Boards.h that gives the directory path of which that category of data should be placed. On Ardupilot, the <g class="gr_ gr_488 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="488" data-gr-id="488">marco</g> HAL_BOARD_TERRAIN_DIRECTORY defines the directory from which terrain data goes.</p>
<p>Once the two <g class="gr_ gr_480 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="480" data-gr-id="480">marcos</g> are fulfilled (that is the board supports <g class="gr_ gr_481 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="481" data-gr-id="481">Posix</g> IO), you can just use <g class="gr_ gr_482 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="482" data-gr-id="482">Posix</g> IO normally as one would (open, close, read, write etc). However, there are some limitations:</p>
<p>-You must only call IO functions from either the IO timer or from your own low priority thread (To not disrupt other more important functions)</p>
<p>-Never call any IO functions from APIs directly accessible in your library. Not even a simple one like stat(). (This could slow down the reading)</p>
<p>-Try to be friendly to slow storage cards, do IO in reasonably sized chunks, and avoid seeks where possible</p>
<p></p>
<p>For does who do not know, seeks is a function (Seek()) where it returns the current position of the file pointer in the named input or output stream. Where file pointer is basically a point that specifies where the next byte will be read and which byte will be read next. For example, if the drone is getting input, the file pointer will be on the latest input. The position of the file pointer can be found through Seek.&nbsp;</p>
<p>A simple IO to <g class="gr_ gr_492 gr-alert gr_gramm gr_inline_cards gr_disable_anim_appear Grammar multiReplace" id="492" data-gr-id="492">a MICROSD</g> card on Pixhawk can take up to a second. Enough time for your drone to go haywire and crash. Usually, the average time for IO between Pixhawk and MICROSD card is very low (think milliseconds) but there might just be a time where the MICROSD card decides to spend a few extra seconds doing god-knows-what. Don't attempt to add in operations that <g class="gr_ gr_495 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" id="495" data-gr-id="495">breaks</g> the above rules.</p>
<p>The only exception to this is initialization functions (Functions that starts something - such as starting the camera) that you are certain will only be called when the drone is starting up or is disarmed. Here, a tiny delay in time is acceptable.</p>
<p>Now go and have a read of libraries/AP_Terrain/TerrainIO.cpp and look at how it uses <g class="gr_ gr_475 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" id="475" data-gr-id="475">Posix</g> IO. Notice the little state machine it uses to handle all the IO, which is all called from the AP_Terrain::io_timer function.</p>[/et_pb_text][et_pb_divider show_divider="on" _builder_version="3.0.51" color="#000000" divider_weight="2px"][/et_pb_divider][et_pb_comments _builder_version="3.0.51"][/et_pb_comments][/et_pb_column][/et_pb_row][/et_pb_section]